CMD и ENTRYPOINT данные слои определяют то, какие мы будем запускать программы в нашем контейнере и какие атрибуты для них мы можем передать

ENTRYPOINT отвечает за то, какую команду мы будем выполнять например "echo"
В то время как CMD определяет переменные для запуска данной команды, например "Hello world", при этом если ENTRYPOINT для CMD не будет определен явно, то CMD может сам решить с какой командой ему запускаться 
При этом, так как CMD является командой зависимой от ENTRYPOINT, мы можем достаточно легко переопределить CMD но ENTRYPOINT переопределить не так просто 

    - Если определён только `CMD`, то он и будет выполняться как команда.
        
    - Если определён только `ENTRYPOINT`, то он будет запущен без аргументов по умолчанию.
        
    - Если определены оба, то `CMD` становится списком аргументов по умолчанию для команды из `ENTRYPOINT`.

FROM это самый первый и самый важный слой нашего приложения, благодаря данному слою мы можем загружать базовый образ для работы с нашим контейнером, будь то alpine который является наиболее легковесным дистрибутивном, рекомендуемым к использованию в контейнерах для экономий ресурсов или к примеру любой ЯП, python/java и тд

COPY и ADD на данном слое мы можем добавлять в наш проект внешние файлы, ссылки или архивы и работать с ними в дальнейшем

При этом, ADD в отличие от COPY может не только добавлять внешние файлы в docker но и распаковывать архивы и даже выгружать архивы по url который мы в ADD передаем, но это влечет за собой дополнительные расходы ресурсов
Поэтому если нам нужно просто добавить файл в docker, лучше это делать всегда через COPY

Инструкция `RUN` выполняется **во время сборки образа** (`docker build`), а не во время запуска контейнера (`docker run`). Её цель — установить пакеты, создать файлы, скомпилировать код и т.д. внутри образа. Это самая важная ошибка в ответе.

HEALTHCHECK - данная инструкция позволяет нам отправлять проверки работоспособности в наш сервис, запущенный внутри контейнера, мы так же можем настроить переодичность данных проверок, при этом рекомендуется сделать задержку перед первой проверкой, так как у сервиса может не хватить времени на запуск и как следствие мы получим контейнер, который вечно будет находится в перезапуске


1. **`WORKDIR`** — Устанавливает рабочую директорию для всех последующих инструкций (`RUN`, `CMD`, `COPY`, `ADD` и т.д.). Аналог `cd` в shell. Крайне важна для правильной организации paths внутри образа.
    
    - _Пример: `WORKDIR /app`_
        
2. **`ENV`** — Устанавливает переменные окружения, которые будут доступны внутри контейнера как во время сборки, так и во время выполнения.
    
    - _Пример: `ENV NODE_ENV=production`_
        
3. **`ARG`** — Определяет переменные, которые передаются только на этапе сборки образа (не сохраняются в финальном образе). Используются для параметризации сборки.
    
    - _Пример: `ARG VERSION=latest`_
        
4. **`EXPOSE`** — Информирует Docker, что контейнер прослушивает указанные сетевые порты. Не пробрасывает порты на хост, а лишь является документацией.
    
    - _Пример: `EXPOSE 80`_
        
5. **`USER`** — Задаёт UID/GID, от имени которого будут выполняться дальнейшие инструкции и запускаться контейнер. Важно для security.
    
    - _Пример: `USER node`_
        
6. **`VOLUME`** — Создаёт точку монтирования для external volumes. Полезно для явного указания, какие данные нужно сохранять.
    
    - _Пример: `VOLUME /data
    [[Хранилище в Docker]]
        
7. **`LABEL`** — Добавляет метаданные к образу (автор, версия, описание). Аналог тегов.
    
    - _Пример: `LABEL maintainer="dev@example.com"`_
        
8. **`.dockerignore`** — Это не инструкция, а файл (аналогичный `.gitignore`), который исключает файлы из контекста сборки, уменьшая размер образа и ускоряя `docker build`.